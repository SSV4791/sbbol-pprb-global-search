# Каркас фабрики ППРБ на HibernateSE

## Описание и правила работы с HibernateSE

HibernateSE - это набор плагинов, которые подключаются к проекту и реализуют интерфейсы Hibernate и встраиваются в
его работу. Например, плагин standin (`sbp.integration.orm:sbp-hibernate-standin`) реализует
`org.hibernate.boot.spi.SessionFactoryBuilderFactory` и переопределяет фабрику своей реализацией.
Также можно посмотреть `com.sbt.pprb.integration.hibernate.adapter.HibernateAdapter` и иерархию вызовов
методов адаптера.

Так как это библиотека, то ссылки на код из предыдущего абзаца могут стать неактуальными. Для самостоятельного
понимания можно посмотреть состав jar и понять, какие классы там есть и как они интегрируются с hibernate.

Учитывая, что HibernateSE представляет собой просто набор плагинов в виде библиотек, всё остальное приложение — это
обычное SpringBoot-приложение с hibernate. Тем не менее, работая с HibernateSE, нужно понимать его особенности:
1. Для работы блокировок при прикладной репликации плагину `sbp-hibernate-standin` нужны служебные таблицы в вашей
   схеме. Создавать их нужно самостоятельно (см. `1628771908126_initial_db_structure.sql`)
2. Нативные запросы можно использовать только для выборки данных. Любые изменения сущностей должны выполняться
   через изменение соответствующих Entity. Это ограничение связано с репликацией данных — нативные запросы нельзя
   перехватить хибернейтом и реплицировать изменения в другую базу. Аналогичным образом запрещено использовать
   update по условию, который может обновить несколько записей в БД (по той же причине)
3. Плагин для StandIn в данном проекте объявляет стратегию работу с партициями `PartitionMultiplyingMode.FORBIDDEN`.
   Эта стратегия запрещает объединение в одной транзакции сущностей с разным ключом хэширования (по ключу хэширования
   определяется партиция в кафке, в которую попадут вектора изменений по сущностям). Таким образом в одну транзакцию
   можно объединять данные только по связанным сущностям (например, данные одного клиента). В проекте в качестве
   ключа хэширования используется digitalId, таким образом все данные по одному клиенту попадают в одну партицию,
   что гарантирует порядок применения изменений по одному клиенту на StandIn-базе.
4. **_ВАЖНО!_**. HibernateSE не дает никаких ограничений по изменению схемы (удаление колонок, изменение обязательности
   и т.д.). Очень важно понимать, что обратная совместимость между двумя версиями приложения — обязательное условие,
   которое ложится на разработчиков. Каждая следующая версия базы данных должна быть обратно совместима с предыдущей
   версией приложения. Так как сначала обновляется БД, а только затем обновляется приложение, нарушение этого пункта
   приведет к полной недоступности фабрики после переключения на обновленную базу.
5. DML. В HibernateSE нет платформенных ограничений на выполнение DML, так как он лишь добавляет нужный функционал
   через плагины. Тем не менее нужно помнить про ограничения, в частности, потенциальная интеграция фабрики с
   КАП (корпоративно-аналитическая платформа / облако данных). Это прикладная интеграция, и все изменения данных,
   которые идут через приложение, так же приложением откидываются в КАП. Скрипты DML идут в обход этой логики и
   модифицируют данные напрямую в БД. Такие изменения никогда не попадут в КАП, в итоге получатся неконсистентные данные
   между фабрикой и КАП. На вопрос, можно ли писать DML-скрипты, ответа на данный момент нет, это задача к обсуждению.

## Правила разработки ППРБ

Актуальные правила разработки, в том числе требования к скриптам в поставке, описаны на странице
https://confluence.sberbank.ru/pages/viewpage.action?pageId=4834432663

## Описание проекта

См. developer-guide (asciidoc/dev-guide).
